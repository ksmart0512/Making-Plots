#%%
# Generate time data every minute from 6am to 10am
start_time = datetime.strptime('06:00', '%H:%M')
end_time = datetime.strptime('10:00', '%H:%M')
time_range = pd.date_range(start=start_time, end=end_time, freq='T')

# Generate dummy lat, lon, height data
np.random.seed(42)  # for reproducibility
import numpy as np
import pandas as pd

# Coordinates for Los Angeles and New York
la_coords = (34.052235, -118.243683)  # Latitude, Longitude of Los Angeles
ny_coords = (40.712776, -74.005974)   # Latitude, Longitude of New York

# Number of waypoints (rows in your DataFrame)
num_points = 100  # Adjust this based on the number of rows you want

# Generate latitudes and longitudes that gradually move from LA to NY
latitudes = np.linspace(la_coords[0], ny_coords[0], num_points)
longitudes = np.linspace(la_coords[1], ny_coords[1], num_points)

# Add a small random noise to make the path more natural (optional)
latitudes += np.random.normal(0, 0.1, num_points)  # Adjust 0.1 for more or less variation
longitudes += np.random.normal(0, 0.1, num_points)

# Generate time data (optional)
time_range = pd.date_range(start='2024-01-01 06:00', periods=num_points, freq='T')

# Create the DataFrame
df_path = pd.DataFrame({
    'time': time_range,
    'latitude': latitudes,
    'longitude': longitudes
})

# Display the DataFrame with the generated path
print(df_path)

heights = np.random.uniform(low=0, high=10000, size=len(time_range))  # in meters

# Create dataframe
df = pd.DataFrame({
    'time': time_range,
    'latitude': latitudes,
    'longitude': longitudes,
    'height': heights
})

# Display or work with the dataframe
print(df.headers(10)

#%% dataframe manipulation

#Filter for every 5 minutes
from datetime import timedelta

# Set the initial time and filtering step
start_time = df['time'].iloc[0]
time_step = timedelta(minutes=5)

# Filter the dataframe based on a 5-minute time difference
filtered_times = [start_time]
for time in df['time']:
    if time >= filtered_times[-1] + time_step:
        filtered_times.append(time)

# Create a filtered dataframe based on the selected times
df_filtered = df[df['time'].isin(filtered_times)].reset_index(drop=True)



from geopy.distance import geodesic

# Initialize velocity column
df_filtered['velocity'] = 0

# Loop through the dataframe to calculate velocity using lat, lon, and time
for i in range(1, len(df_filtered)):
    # Calculate the distance between the current and previous point in meters
    coord1 = (df_filtered['latitude'].iloc[i-1], df_filtered['longitude'].iloc[i-1])
    coord2 = (df_filtered['latitude'].iloc[i], df_filtered['longitude'].iloc[i])
    distance = geodesic(coord1, coord2).meters
    
    # Calculate the time difference in seconds
    time_diff = (df_filtered['time'].iloc[i] - df_filtered['time'].iloc[i-1]).total_seconds()
    
    # Calculate velocity (m/s)
    velocity = distance / time_diff if time_diff != 0 else 0
    df_filtered.at[i, 'velocity'] = velocity


# Display or work with the filtered dataframe
print(df_filtered.header(10))

# Calculate velocity based on the change in height over the change in time
df_filtered['velocity'] = 0  # Initialize velocity column

for i in range(1, len(df_filtered)):
    # Calculate time difference in seconds
    time_diff = (df_filtered['time'].iloc[i] - df_filtered['time'].iloc[i-1]).total_seconds()
    
    # Calculate height difference
    height_diff = df_filtered['height'].iloc[i] - df_filtered['height'].iloc[i-1]
    
    # Calculate velocity (m/s)
    velocity = height_diff / time_diff if time_diff != 0 else 0
    df_filtered.at[i, 'velocity'] = velocity

